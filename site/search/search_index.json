{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DeFiOrg.com DeFi Foundation is an org. commited to establishing voluntary standards, frameworks, best practices to help promote the DeFi Ecosystem. To add either raise a GitHub issue please. Contributers @sambacha @kermankohli Ecosystem Twitter @DefiPrime @DeFiPulse Telegram Channels DeFi Channel FlashFck Research Discords pending. How you can help GitHub Issues and Pull Requests Licenses Apache 2.0 and Creative Commons Share a-like 2.5 Donations No Thanks.","title":"DeFiOrg.com"},{"location":"#defiorgcom","text":"DeFi Foundation is an org. commited to establishing voluntary standards, frameworks, best practices to help promote the DeFi Ecosystem. To add either raise a GitHub issue please.","title":"DeFiOrg.com"},{"location":"#contributers","text":"@sambacha @kermankohli","title":"Contributers"},{"location":"#ecosystem","text":"","title":"Ecosystem"},{"location":"#twitter","text":"@DefiPrime @DeFiPulse","title":"Twitter"},{"location":"#telegram-channels","text":"DeFi Channel FlashFck Research","title":"Telegram Channels"},{"location":"#discords","text":"pending.","title":"Discords"},{"location":"#how-you-can-help","text":"GitHub Issues and Pull Requests","title":"How you can help"},{"location":"#licenses","text":"Apache 2.0 and Creative Commons Share a-like 2.5","title":"Licenses"},{"location":"#donations","text":"No Thanks.","title":"Donations"},{"location":"defi-audit/","text":"DeFi Audit Key Points Code quality: Trusting teams have implemented best practices for developing high quality, tested software should not be taken for taken for granted. Detailed due diligence needs be done at regular intervals. Ownership structure & upgrade logic: Knowing the ownership structure of the protocol is much more important than just saying \"oh look it has an admin key\"! Most of the time the admin is a contract which has its own logic. Furthermore analysis around how often the admin key is used should be done including how easy is to audit what the changes actually are. Liquidity Analysis: On-going monitoring around the attack vector of flash loan liquidity compared to assets used by platform liquidity. This is something that you can kind of gauge at the moment but isn't really easy to continually check. Teams should think about what safe-guards they're taking to ensure bootstrapping liquidity slowly isn't vulnerable to flash loan attacks. Governance tokens beware. Oracle Analysis: If you're going to use on-chain oracles, don't just assume a large whale won't manipulate them, actually do the math! I think before it's been too easy to dismiss the fact that a large whale wouldn't risk their capital. Now anyone can become a whale without the capital! Bootstrap Insurance Liquidity: With the advent of new insurance protocols such as Nexus and Opyn, taking the other side of the insurance is a great way to signal confidence to your users that you're willing to pay out losses in the case that they want insurance. It probably won't even cost that much considering a static solidity audit runs $50k - $200k USD and most people won't purchase insurance. Adding to this, just lend out funds in a lending protocol earning interest while you have your ETH/DAI parked inside. Liquidity Caps: As much as everyone wants to ship fast, rushing the deployment process and not capping your down-side can be a hazard. If you're going to cut corners, ensure that the total amount lost is on a much smaller scale. MakerDAO is a great example of this by having the cap on total amount of DAI being able to be minted. Lending protocols might want to think about adding a cap similar to this as well. sources DeFi Weekly","title":"DeFi Audit"},{"location":"defi-audit/#defi-audit","text":"","title":"DeFi Audit"},{"location":"defi-audit/#key-points","text":"Code quality: Trusting teams have implemented best practices for developing high quality, tested software should not be taken for taken for granted. Detailed due diligence needs be done at regular intervals. Ownership structure & upgrade logic: Knowing the ownership structure of the protocol is much more important than just saying \"oh look it has an admin key\"! Most of the time the admin is a contract which has its own logic. Furthermore analysis around how often the admin key is used should be done including how easy is to audit what the changes actually are. Liquidity Analysis: On-going monitoring around the attack vector of flash loan liquidity compared to assets used by platform liquidity. This is something that you can kind of gauge at the moment but isn't really easy to continually check. Teams should think about what safe-guards they're taking to ensure bootstrapping liquidity slowly isn't vulnerable to flash loan attacks. Governance tokens beware. Oracle Analysis: If you're going to use on-chain oracles, don't just assume a large whale won't manipulate them, actually do the math! I think before it's been too easy to dismiss the fact that a large whale wouldn't risk their capital. Now anyone can become a whale without the capital! Bootstrap Insurance Liquidity: With the advent of new insurance protocols such as Nexus and Opyn, taking the other side of the insurance is a great way to signal confidence to your users that you're willing to pay out losses in the case that they want insurance. It probably won't even cost that much considering a static solidity audit runs $50k - $200k USD and most people won't purchase insurance. Adding to this, just lend out funds in a lending protocol earning interest while you have your ETH/DAI parked inside. Liquidity Caps: As much as everyone wants to ship fast, rushing the deployment process and not capping your down-side can be a hazard. If you're going to cut corners, ensure that the total amount lost is on a much smaller scale. MakerDAO is a great example of this by having the cap on total amount of DAI being able to be minted. Lending protocols might want to think about adding a cap similar to this as well. sources DeFi Weekly","title":"Key Points"},{"location":"protocol-continuity-planning/","text":"Protocol Continuity Planning Protocol Continuity Planning is the process of creating systems of prevention and recovery to deal with potential threats to a protocol. In addition to prevention, the goal is to enable ongoing operations before and during execution of disaster recovery, for example should an admin key be compromised. Prepare for failure Any non-trivial contract will have errors in it. Your code must, therefore, be able to respond to bugs and vulnerabilities gracefully. Pause the contract when things are going wrong ('circuit breaker') Manage the amount of money at risk (rate limiting, maximum usage) Have an effective upgrade path for bugfixes and improvements Rollout carefully It is always better to catch bugs before a full production release. Test contracts thoroughly, and add tests whenever new attack vectors are discovered Provide bug bounties starting from alpha testnet releases Rollout in phases, with increasing usage and testing in each phase Keep contracts simple Complexity increases the likelihood of errors. Ensure the contract logic is simple Modularize code to keep contracts and functions small Use already-written tools or code where possible (eg. don't roll your own random number generator) Prefer clarity to performance whenever possible Only use the blockchain for the parts of your system that require decentralization Stay up to date Keep track of new security developments. Check your contracts for any new bug as soon as it is discovered Upgrade to the latest version of any tool or library as soon as possible Adopt new security techniques that appear useful sources: consensys smart contract best practices","title":"Protocol Continuity Planning"},{"location":"protocol-continuity-planning/#protocol-continuity-planning","text":"Protocol Continuity Planning is the process of creating systems of prevention and recovery to deal with potential threats to a protocol. In addition to prevention, the goal is to enable ongoing operations before and during execution of disaster recovery, for example should an admin key be compromised.","title":"Protocol Continuity Planning"},{"location":"protocol-continuity-planning/#prepare-for-failure","text":"Any non-trivial contract will have errors in it. Your code must, therefore, be able to respond to bugs and vulnerabilities gracefully. Pause the contract when things are going wrong ('circuit breaker') Manage the amount of money at risk (rate limiting, maximum usage) Have an effective upgrade path for bugfixes and improvements","title":"Prepare for failure"},{"location":"protocol-continuity-planning/#rollout-carefully","text":"It is always better to catch bugs before a full production release. Test contracts thoroughly, and add tests whenever new attack vectors are discovered Provide bug bounties starting from alpha testnet releases Rollout in phases, with increasing usage and testing in each phase","title":"Rollout carefully"},{"location":"protocol-continuity-planning/#keep-contracts-simple","text":"Complexity increases the likelihood of errors. Ensure the contract logic is simple Modularize code to keep contracts and functions small Use already-written tools or code where possible (eg. don't roll your own random number generator) Prefer clarity to performance whenever possible Only use the blockchain for the parts of your system that require decentralization","title":"Keep contracts simple"},{"location":"protocol-continuity-planning/#stay-up-to-date","text":"Keep track of new security developments. Check your contracts for any new bug as soon as it is discovered Upgrade to the latest version of any tool or library as soon as possible Adopt new security techniques that appear useful sources: consensys smart contract best practices","title":"Stay up to date"}]}